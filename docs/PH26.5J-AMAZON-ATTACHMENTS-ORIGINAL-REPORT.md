# PH26.5J — Amazon Attachments: Capture Inline Images

**Date** : 2026-01-30  
**Status** : ✅ Fix déployé (validation sur prochain message)

---

## Objectif

Vérifier si le MIME original contient des images plus grosses que celles capturées, et améliorer le parser pour capturer les images inline.

---

## Analyse du message Alycia (20260130_150548.jpg)

### Données actuelles

| Élément | Valeur |
|---------|--------|
| ID attachment | `att_abc40e20df9a9cc959669813` |
| Filename | `20260130_150548.jpg` |
| Size | 369987 bytes |
| Body message | `[Pièce jointe reçue]` (placeholder) |

### Raw MIME stocké ?

**NON** — Le raw MIME n'est pas conservé après parsing. La colonne `raw` dans `ExternalMessage` ne contient pas le contenu complet avec base64.

**Conséquence** : Impossible de rejouer le parsing sur ce message existant.

---

## Problème identifié dans le code

### Avant (code original)

```typescript
// attachmentParser.service.ts ligne 137
const isAttachmentCandidate = !!filename || contentDisposition === 'attachment';
```

**Problème** : Une image inline (Content-Disposition: inline) sans filename est ignorée.

### Exemple de part ignorée

```
Content-Type: image/jpeg
Content-Disposition: inline
Content-Transfer-Encoding: base64

/9j/4AAQSkZJRgABAQEASABIAAD...  (2+ MB)
```

Cette image de 2+ MB serait ignorée car :
- `filename` = null
- `contentDisposition` = "inline" (≠ "attachment")

---

## Fix PH26.5J

### Nouvelle logique de sélection

```typescript
const isTextCandidate = contentType.startsWith('text/') && !filename && contentDisposition !== 'attachment';

// PH26.5J: Capture inline images > 50KB (likely photos, not email signatures)
const isInlineImage = contentType.startsWith('image/') && content.length > 50000;
const isAttachmentCandidate = !!filename || contentDisposition === 'attachment' || isInlineImage;
```

### Seuil de 50KB

Le seuil de 50KB différencie :
- **Petites images** (< 50KB) : signatures email, logos → ignorées
- **Grandes images** (> 50KB) : photos, captures → capturées comme attachments

### Génération de filename

Pour les images inline sans filename :

```typescript
// PH26.5J: Generate meaningful filename for inline images
const ext = part.contentType.split('/')[1]?.split(';')[0] || 'bin';
part.filename = 'inline_image_' + part.index + '_' + Date.now() + '.' + ext;
```

Exemple : `inline_image_3_1769807000.jpeg`

### Logging amélioré

```
[MimeParser PH26.5A] Part 3: type=image/jpeg, disp=inline, file=none, enc=base64, size=2900000, isText=false, isAtt=true, isInlineImg=true
```

---

## Image déployée

| Service | Tag | Digest |
|---------|-----|--------|
| Backend | `v1.0.40-ph265j` | `sha256:ba3168364acdbd4c1f6edaf8eacc23db18d6745b12c7b243085e49fc9cf089f2` |

---

## Validation

### Ce qui peut être validé maintenant

1. ✅ Le code est déployé
2. ✅ La logique de sélection inclut les images inline > 50KB

### Ce qui nécessite un nouveau message

Pour valider complètement :
1. Recevoir un nouveau message Amazon avec PJ
2. Vérifier dans les logs : `isInlineImg=true` pour les grandes images
3. Vérifier que l'attachment est stocké avec la taille correcte

### Commande de vérification (après réception)

```bash
kubectl logs -n keybuzz-backend-dev deployment/keybuzz-backend --tail=100 | grep "MimeParser"
```

---

## Recommandations futures

1. **Stocker le raw MIME** : Permettrait le replay en cas de bug
2. **Garder toutes les images** : Si plusieurs images, stocker toutes (pas juste la première)
3. **Comparer avec original** : Si possible, comparer la taille stockée avec la taille déclarée dans le header Content-Length MIME

---

## Fichiers modifiés

| Fichier | Modification |
|---------|--------------|
| `attachmentParser.service.ts` | `isInlineImage` pour images > 50KB |
| `attachmentParser.service.ts` | Log `isInlineImg` flag |
| `attachmentParser.service.ts` | Filename `inline_image_X_timestamp.ext` |

---

**STATUS** : ✅ Fix déployé, en attente de validation sur prochain message
