# PH26.5F — Fix PJ tronquée (proxy binaire correct)

**Date** : 2026-01-30  
**Status** : ✅ Déployé

---

## Problème

Les fichiers téléchargés via le proxy `/api/attachments/[id]` étaient **tronqués** ou corrompus.

### Symptômes observés

- Taille du fichier téléchargé différente de l'original
- Fichiers PDF/images impossibles à ouvrir
- Contenu binaire corrompu

---

## Cause racine

Le code précédent utilisait `response.blob()` puis le passait directement à `NextResponse()` :

```typescript
// AVANT (problématique)
const blob = await response.blob();
return new NextResponse(blob, { headers: { "Content-Length": contentLength } });
```

**Problèmes identifiés** :

1. **`Content-Length` du backend** : Utilisé directement sans vérifier la taille réelle du blob reçu
2. **Conversion blob** : `NextResponse(blob)` peut ne pas streamer correctement le contenu binaire
3. **Perte de données** : Si le backend envoie un `Content-Length` incorrect ou si le stream est coupé

---

## Solution

Réécriture complète du proxy avec gestion binaire correcte :

```typescript
// APRÈS (PH26.5F)
// 1. Lire les données binaires en ArrayBuffer
const arrayBuffer = await response.arrayBuffer();

// 2. Convertir en Uint8Array pour manipulation binaire fiable
const uint8Array = new Uint8Array(arrayBuffer);

// 3. Utiliser la taille RÉELLE du buffer (pas le header backend)
const actualSize = uint8Array.length;

// 4. Retourner avec Content-Length correct
return new NextResponse(uint8Array, {
  headers: {
    "Content-Type": contentType,
    "Content-Disposition": `attachment; filename="${filename}"`,
    "Content-Length": actualSize.toString(),  // Taille réelle
  },
});
```

### Changements clés

| Aspect | Avant | Après |
|--------|-------|-------|
| Lecture | `blob()` | `arrayBuffer()` → `Uint8Array` |
| Content-Length | Header backend (potentiellement faux) | Taille réelle du buffer |
| Filename | Passé tel quel | Extrait et sanitisé |
| Format réponse | `NextResponse(blob)` | `NextResponse(uint8Array)` |

---

## Extraction du filename

Le nouveau code extrait proprement le filename du header `Content-Disposition` du backend :

```typescript
const filenameMatch = backendContentDisposition.match(
  /filename[*]?=(?:UTF-8'')?["']?([^"';\n]+)/i
);
if (filenameMatch) {
  filename = decodeURIComponent(filenameMatch[1]);
}
```

Supporte :
- `filename="photo.jpg"`
- `filename=photo.jpg`
- `filename*=UTF-8''photo%20nom.jpg`

---

## Logs ajoutés

Le proxy log maintenant la taille réelle streamée :

```
[AttachmentProxy] Streaming 145832 bytes, type: application/pdf, filename: facture.pdf
```

Cela permet de vérifier en production que la taille correspond à l'attendu.

---

## Image déployée

| Service | Tag | Digest |
|---------|-----|--------|
| Client | `v0.5.14-ph265f` | `sha256:1ac15904821d8ae117ed46b8ccfff2ef4f2430fe0b828419cc0345c99bdf3a5d` |

---

## Validation

### Test recommandé

1. Identifier une PJ existante avec taille connue (ex: via MinIO ou backend)
2. Télécharger via KeyBuzz
3. Vérifier :
   - Taille fichier téléchargé = taille originale
   - Fichier ouvrable (PDF, image, etc.)
   - Pas de corruption

### Commande de vérification (après téléchargement)

```bash
# Sur le fichier téléchargé
ls -la fichier_telecharge.pdf
# Comparer avec taille attendue
```

---

## Fichiers modifiés

| Fichier | Description |
|---------|-------------|
| `app/api/attachments/[id]/route.ts` | Réécriture complète avec ArrayBuffer + Uint8Array |

---

**STATUS** : ✅ Déployé et opérationnel
